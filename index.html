<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>BuildStrong — Unity Style</title>
<style>
  :root{color-scheme:dark}
  *{box-sizing:border-box}
  body{margin:0;background:#0b1220;color:#e6eaf2;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .app{max-width:980px;margin:0 auto;padding:16px 12px 96px}
  h1{margin:0 0 6px;font-size:28px}
  h2{margin:0;font-size:18px}
  .muted{opacity:.75;font-size:12px}
  .tabs{display:flex;gap:8px;margin:10px 0 12px;flex-wrap:wrap}
  .tab{
    flex:1;min-width:110px;cursor:pointer;
    background:#101a30;border:1px solid rgba(255,255,255,.14);color:#e6eaf2;
    padding:12px;border-radius:12px;font-weight:900
  }
  .tab.active{background:#2b63ff;border-color:#2b63ff}
  .pane{display:none}
  .pane.active{display:block}

  .card{background:#101a30;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;margin:10px 0}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .row.stack{display:flex}
  @media (max-width:760px){ .row.stack{display:grid;grid-template-columns:1fr;gap:8px} }

  .btn{
    background:#2b63ff;border:0;color:#fff;padding:12px 14px;border-radius:12px;
    cursor:pointer;font-weight:900
  }
  .btn.ghost{background:#0f1a34;border:1px solid rgba(255,255,255,.16)}
  .btn.small{padding:10px 12px}
  .btn:active{transform:translateY(1px)}

  label{font-size:12px;opacity:.85;display:block;margin:8px 0 4px}
  select,input[type="text"],input[type="number"]{
    width:100%;background:#0d1830;border:1px solid rgba(255,255,255,.18);
    color:#e6eaf2;padding:10px;border-radius:10px
  }

  .sessionHead{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .meta{display:flex;gap:8px;flex-wrap:wrap}
  .pill{display:inline-flex;gap:8px;align-items:center;background:#182446;border-radius:999px;padding:6px 12px;font-size:12px}

  .zone{margin-top:12px}
  .zoneTitle{
    display:flex;justify-content:space-between;gap:10px;align-items:center;
    border-top:1px solid rgba(255,255,255,.12);
    padding-top:10px;margin-top:10px
  }
  .zoneTitle b{font-size:14px}
  .zoneTitle span{font-size:12px;opacity:.8}

  .item{background:#0e182c;border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px;margin:8px 0}
  .itemTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
  .name{font-weight:950;min-width:0}
  .sub{display:block;margin-top:2px;font-weight:750;opacity:.88}
  .line{margin-top:8px;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;opacity:.95}

  .ctrl{display:inline-flex;gap:8px;align-items:center}
  .cbtn{
    background:#0f1a34;border:1px solid rgba(255,255,255,.22);color:#e6eaf2;
    border-radius:10px;padding:6px 10px;font-weight:950;cursor:pointer
  }
  .cval{min-width:90px;text-align:center;font-weight:950}
  .ltog{
    background:#182446;border:1px solid rgba(255,255,255,.18);color:#e6eaf2;
    border-radius:10px;padding:6px 10px;font-weight:950;cursor:pointer
  }
  .ltog.done{background:#2b63ff;border-color:#2b63ff}

  .grid{display:grid;gap:10px}
  .cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  @media (max-width:760px){ .cols-2{grid-template-columns:1fr} }

  .setupCard h3{margin:0 0 10px;font-size:16px}
  .setupRow{
    display:grid;grid-template-columns:160px 1fr 120px 110px 160px;
    gap:10px;align-items:center;margin:10px 0
  }
  @media (max-width:760px){ .setupRow{grid-template-columns:1fr;gap:8px} }

  details{border:1px solid rgba(255,255,255,.08);border-radius:12px;background:#0f1a34}
  summary{list-style:none;cursor:pointer;padding:12px;font-weight:950}
  summary::-webkit-details-marker{display:none}
  details[open]>summary{border-bottom:1px solid rgba(255,255,255,.10)}
  .panel{padding:12px}
</style>
</head>
<body>
<div class="app">
  <h1>BuildStrong</h1>

  <div class="tabs">
    <button class="tab active" data-tab="planner">Planner</button>
    <button class="tab" data-tab="custom">Custom exercises</button>
    <button class="tab" data-tab="settings">Settings</button>
  </div>

  <!-- PLANNER -->
  <div class="pane active" id="pane-planner">
    <div class="row stack" style="margin:8px 0 12px">
      <button class="btn ghost" id="btnPrev">◀ Prev</button>
      <button class="btn" id="btnNext">Next ▶</button>
      <button class="btn ghost" id="btnResetSession">Reset session</button>
    </div>

    <div class="card">
      <div class="sessionHead">
        <div>
          <h2 id="headTitle">Week 1 • Session 1</h2>
          <div class="muted" id="headSub">—</div>
        </div>
        <div class="meta" id="kpi"></div>
      </div>
      <div id="planWrap"></div>
    </div>
  </div>

  <!-- CUSTOM EXERCISES -->
  <div class="pane" id="pane-custom">
    <div class="card">
      <h2>Custom exercises</h2>
      <div class="muted" id="customHint"></div>
    </div>
    <div id="customWrap"></div>
    <div class="card">
      <div class="row stack">
        <button class="btn" id="btnSaveCustom">Save</button>
        <button class="btn ghost" id="btnResetCustom">Reset custom exercises</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS -->
  <div class="pane" id="pane-settings">
    <div class="card">
      <h2>Settings</h2>

      <div class="grid cols-2" style="margin-top:8px">
        <div>
          <label>Template</label>
          <select id="selTemplate">
            <option value="BTS3">BTS3</option>
            <option value="BTS4">BTS4</option>
            <option value="BTS6" selected>BTS6</option>
          </select>
        </div>
        <div>
          <label>Block volume</label>
          <select id="selVol">
            <option>200</option>
            <option>240</option>
            <option selected>300</option>
            <option>360</option>
            <option>420</option>
          </select>
        </div>
      </div>

      <details style="margin-top:12px" open>
        <summary>Rules</summary>
        <div class="panel muted">
          Week-wave: <b>15–28–22–35</b> (Deload / Development / Maintenance / Stress)<br/>
          Zone split (per week): <b>15% Heavy</b> / <b>35% Medium</b> / <b>50% Light</b><br/>
          Ladder: <b>C = floor(0.66 × RM)</b>, choose <b>a+b=C</b>, enforce <b>delta20</b> between rungs.
        </div>
      </details>

      <div class="row stack" style="margin-top:12px">
        <button class="btn" id="btnNewBlock">New block</button>
        <button class="btn ghost" id="btnClearAll">Clear all progress</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const LS_KEY = "BUILDSTRONG_UNITYSTYLE_COMPLETE_V1";

  const WEEK_WAVE = [
    { pct: 0.15, name: "Deload" },
    { pct: 0.28, name: "Development" },
    { pct: 0.22, name: "Maintenance" },
    { pct: 0.35, name: "Stress" },
  ];

  const ZONES = [
    { key:"H", name:"Heavy",  range:"4–7",   pct:0.15 },
    { key:"M", name:"Medium", range:"8–11",  pct:0.35 },
    { key:"L", name:"Light",  range:"12–15", pct:0.50 },
  ];

  const TEMPLATES = {
    BTS3: {
      name:"BTS3",
      movements:[
        {id:"push",  label:"Push"},
        {id:"pull",  label:"Pull"},
        {id:"lower", label:"Lower"},
      ],
      sessions:[
        { title:"Push Day",  blocks:[ {movement:"push",zone:"H"},{movement:"push",zone:"M"},{movement:"push",zone:"L"} ] },
        { title:"Pull Day",  blocks:[ {movement:"pull",zone:"H"},{movement:"pull",zone:"M"},{movement:"pull",zone:"L"} ] },
        { title:"Lower Day", blocks:[ {movement:"lower",zone:"H"},{movement:"lower",zone:"M"},{movement:"lower",zone:"L"} ] },
      ],
    },

    // IMPORTANT: BTS4 "Upper" is a SESSION CONCEPT, but movements stay Push+Pull separately.
    BTS4: {
      name:"BTS4",
      movements:[
        {id:"push",  label:"Push"},
        {id:"pull",  label:"Pull"},
        {id:"squat", label:"Squat"},
        {id:"hinge", label:"Hinge"},
      ],
      sessions:[
        { title:"Full Body", blocks:[
          {movement:"squat",zone:"H"},
          {movement:"push",zone:"M"},{movement:"pull",zone:"M"},
          {movement:"hinge",zone:"L"},
        ]},
        { title:"Full Body", blocks:[
          {movement:"push",zone:"H"},{movement:"pull",zone:"H"},
          {movement:"hinge",zone:"M"},
          {movement:"squat",zone:"L"},
        ]},
        { title:"Full Body", blocks:[
          {movement:"hinge",zone:"H"},
          {movement:"squat",zone:"M"},
          {movement:"push",zone:"L"},{movement:"pull",zone:"L"},
        ]},
      ],
    },

    BTS6: {
      name:"BTS6",
      movements:[
        {id:"pushHor", label:"Push Horizontal"},
        {id:"pullHor", label:"Pull Horizontal"},
        {id:"pushVer", label:"Push Vertical"},
        {id:"pullVer", label:"Pull Vertical"},
        {id:"squat",   label:"Squat"},
        {id:"hinge",   label:"Hinge"},
      ],
      sessions:[
        { title:"Upper A", blocks:[
          {movement:"pushHor",zone:"H"},{movement:"pullHor",zone:"H"},
          {movement:"pushVer",zone:"M"},{movement:"pullVer",zone:"M"},
          {movement:"pushHor",zone:"L"},{movement:"pullHor",zone:"L"},
        ]},
        { title:"Lower A", blocks:[
          {movement:"squat",zone:"H"},{movement:"hinge",zone:"M"},{movement:"squat",zone:"L"},
        ]},
        { title:"Upper B", blocks:[
          {movement:"pushVer",zone:"H"},{movement:"pullVer",zone:"H"},
          {movement:"pushHor",zone:"M"},{movement:"pullHor",zone:"M"},
          {movement:"pushVer",zone:"L"},{movement:"pullVer",zone:"L"},
        ]},
        { title:"Lower B", blocks:[
          {movement:"hinge",zone:"H"},{movement:"squat",zone:"M"},{movement:"hinge",zone:"L"},
        ]},
      ],
    },
  };

  const $ = (s) => document.querySelector(s);
  const esc = (s) => String(s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const mod = (n,m)=>((n%m)+m)%m;

  function zoneTargets(blockVolume){
    const out={};
    for (const z of ZONES) out[z.key]=Math.round(Number(blockVolume)*z.pct);
    return out;
  }

  // Ladder rule:
  // C = floor(0.66*RM)
  // find a such that:
  // - a + b = C
  // - delta20 between a and b: (b-a)/b >= 0.2
  // - delta20 between b and C: (C-b)/C >= 0.2  => a/C >= 0.2
  // choose a closest to C/3 (stable feeling)
  function buildLadder(repMax){
    const rm = Math.max(1, Number(repMax)||1);
    const C = Math.max(1, Math.floor(0.66 * rm));

    const minA = Math.max(1, Math.ceil(0.20 * C));        // ensures b vs C delta20
    const maxA = Math.max(1, Math.floor(0.50 * C));       // keep a <= b
    let best = null;

    for (let a=minA; a<=maxA; a++){
      const b = C - a;
      if (b < 1) continue;
      const deltaAB = (b - a) / b;        // >= 0.2
      const deltaBC = (C - b) / C;        // = a/C >= 0.2
      if (deltaAB >= 0.20 && deltaBC >= 0.20){
        const score = Math.abs(a - (C/3));
        if (!best || score < best.score) best = {a,b,score};
      }
    }

    if (!best){
      // fallback: still keep a+b=C, and keep it reasonable
      const a = Math.max(1, Math.floor(C/3));
      const b = Math.max(1, C-a);
      return {a:Math.min(a,b), b:Math.max(a,b), C, volume:(a+b+C)};
    }
    return {a:best.a, b:best.b, C, volume:(best.a+best.b+C)};
  }

  function planForTarget(targetReps, ladder){
    const t = Math.max(0, targetReps|0);
    const full = ladder.volume>0 ? Math.floor(t/ladder.volume) : 0;
    const leftover = ladder.volume>0 ? (t % ladder.volume) : t;
    // leftover is "hidden"; we only display its total
    return { fullLadders: full, leftoverTotal: leftover };
  }

  function buildDefaultStacks(templateKey){
    const tpl = TEMPLATES[templateKey];
    const stacks = {};
    for (const mv of tpl.movements){
      stacks[mv.id] = {
        H:{exercise:"",load:"",repMax:5},
        M:{exercise:"",load:"",repMax:10},
        L:{exercise:"",load:"",repMax:15},
      };
    }
    return stacks;
  }

  function defaultState(){
    return {
      template:"BTS6",
      blockVolume:300,
      sessionCursor:0,
      stacks:buildDefaultStacks("BTS6"),
      remaining:{},
      progress:{},
    };
  }

  function ensureRemaining(st){
    const tpl=TEMPLATES[st.template];
    const tgt=zoneTargets(st.blockVolume);
    st.remaining = st.remaining || {};
    for (const mv of tpl.movements){
      st.remaining[mv.id] = st.remaining[mv.id] || {};
      for (const z of ZONES){
        if (typeof st.remaining[mv.id][z.key] !== "number") st.remaining[mv.id][z.key] = tgt[z.key];
      }
    }
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw){
        const st=defaultState(); ensureRemaining(st); return st;
      }
      const st=JSON.parse(raw);
      if (!st.template) return defaultState();
      if (!st.progress) st.progress = {};
      if (!st.stacks) st.stacks = buildDefaultStacks(st.template);
      if (typeof st.sessionCursor !== "number") st.sessionCursor = 0;
      if (typeof st.blockVolume !== "number") st.blockVolume = Number(st.blockVolume)||300;

      // upgrade stacks if template changed / missing movement ids
      const tpl=TEMPLATES[st.template];
      for (const mv of tpl.movements){
        if (!st.stacks[mv.id]){
          st.stacks[mv.id]={H:{exercise:"",load:"",repMax:5},M:{exercise:"",load:"",repMax:10},L:{exercise:"",load:"",repMax:15}};
        }
      }
      ensureRemaining(st);
      return st;
    }catch(e){
      console.error(e);
      const st=defaultState(); ensureRemaining(st); return st;
    }
  }

  let state = loadState();
  function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }

  function movementLabel(mvId){
    const tpl=TEMPLATES[state.template];
    return (tpl.movements.find(m=>m.id===mvId)?.label) || mvId;
  }

  function progressKey(globalWeekIndex, sessionIndex, blockIndex){
    return `${state.template}|v${state.blockVolume}|w${globalWeekIndex}|s${sessionIndex}|b${blockIndex}`;
  }

  function countOccurrencesPerWeek(tpl, movementId, zoneKey){
    let n=0;
    for (const s of tpl.sessions){
      for (const b of s.blocks){
        if (b.movement===movementId && b.zone===zoneKey) n++;
      }
    }
    return n;
  }

  function weekZoneTarget(blockVolume, phasePct, zonePct){
    return Math.round(Number(blockVolume) * phasePct * zonePct);
  }

  function computeAppliedReps(doneLadders, ladder, leftoverTotal, leftoverDone){
    return (doneLadders|0)*ladder.volume + (leftoverDone ? (leftoverTotal|0) : 0);
  }

  function appliedThisWeek(tpl, globalWeekIndex, movementId, zoneKey){
    let total=0;
    for (let sIdx=0; sIdx<tpl.sessions.length; sIdx++){
      const session = tpl.sessions[sIdx];
      session.blocks.forEach((blk, bi)=>{
        if (blk.movement!==movementId || blk.zone!==zoneKey) return;
        const key = progressKey(globalWeekIndex, sIdx, bi);
        const entry = state.progress[key];
        if (entry && typeof entry.appliedReps==="number") total += entry.appliedReps;
      });
    }
    return total;
  }

  function applyDeltaToRemaining(mvId, zKey, delta){
    const tgt = zoneTargets(state.blockVolume)[zKey];
    const cur = state.remaining[mvId][zKey];
    let next = cur - delta;
    next = Math.max(0, Math.min(tgt, next));
    state.remaining[mvId][zKey] = next;
  }

  function ensureProgressEntry(globalWeekIndex, sessionIndex, blockIndex){
    const key=progressKey(globalWeekIndex, sessionIndex, blockIndex);
    if (!state.progress[key]){
      state.progress[key] = {doneLadders:0, leftoverDone:false, appliedReps:0};
    }
    return state.progress[key];
  }

  function updateProgressAndRemaining(globalWeekIndex, sessionIndex, blockIndex, mvId, zKey, ladder, planFullLadders, leftoverTotal, newDoneLadders, newLeftoverDone){
    const key=progressKey(globalWeekIndex, sessionIndex, blockIndex);
    const entry=state.progress[key];

    newDoneLadders = Math.max(0, Math.min(planFullLadders, newDoneLadders|0));
    newLeftoverDone = !!newLeftoverDone;

    const oldApplied = entry.appliedReps || 0;
    const nextApplied = computeAppliedReps(newDoneLadders, ladder, leftoverTotal, newLeftoverDone);
    const delta = nextApplied - oldApplied;

    if (delta > 0){
      const remaining = state.remaining[mvId][zKey];
      const allowed = Math.min(delta, remaining);
      applyDeltaToRemaining(mvId, zKey, allowed);
      entry.appliedReps = oldApplied + allowed;
    } else if (delta < 0){
      applyDeltaToRemaining(mvId, zKey, delta); // negative adds back
      entry.appliedReps = nextApplied;
    }

    entry.doneLadders = newDoneLadders;
    entry.leftoverDone = newLeftoverDone;
    saveState();
  }

  function blockDonePct(){
    const tpl=TEMPLATES[state.template];
    let total=0, rem=0;
    const tgt=zoneTargets(state.blockVolume);
    for (const mv of tpl.movements){
      for (const z of ZONES){
        total += tgt[z.key];
        rem   += state.remaining[mv.id][z.key];
      }
    }
    const done = total - rem;
    return total>0 ? Math.round((done/total)*100) : 0;
  }

  function renderKPI(phase){
    const tpl=TEMPLATES[state.template];
    $("#kpi").innerHTML = [
      `<span class="pill">Template <b>${tpl.name}</b></span>`,
      `<span class="pill">Block <b>${state.blockVolume}</b></span>`,
      `<span class="pill">Week <b>${phase.name}</b></span>`,
      `<span class="pill">Progress <b>${blockDonePct()}%</b></span>`
    ].join("");
  }

  function renderPlanner(){
    ensureRemaining(state);
    const tpl = TEMPLATES[state.template];

    const sPerWeek = tpl.sessions.length;
    const cursor = state.sessionCursor|0;

    const globalWeekIndex = Math.floor(cursor / sPerWeek);
    const week = globalWeekIndex + 1;

    const phase = WEEK_WAVE[mod(globalWeekIndex, WEEK_WAVE.length)];
    const sessionIdx = mod(cursor, sPerWeek);
    const session = tpl.sessions[sessionIdx];

    $("#headTitle").textContent = `Week ${week} • Session ${sessionIdx+1}`;
    $("#headSub").textContent = `${tpl.name} • ${session.title} • ${phase.name}`;

    renderKPI(phase);

    const wrap = $("#planWrap");
    wrap.innerHTML = "";

    // group by zone so you have clear "lines" between H/M/L
    const byZone = {H:[],M:[],L:[]};
    session.blocks.forEach((b,i)=>byZone[b.zone].push({blk:b, idx:i}));

    for (const zKey of ["H","M","L"]){
      const zMeta = ZONES.find(z=>z.key===zKey);

      const zoneDiv = document.createElement("div");
      zoneDiv.className = "zone";
      zoneDiv.innerHTML = `<div class="zoneTitle"><b>${zMeta.name}</b><span>${zMeta.range}</span></div>`;

      for (const {blk, idx} of byZone[zKey]){
        const mvId = blk.movement;
        const spec = state.stacks[mvId][zKey];
        const ladder = buildLadder(spec.repMax);

        const remainingBlock = Math.max(0, state.remaining[mvId][zKey]);

        const weekTarget = weekZoneTarget(state.blockVolume, phase.pct, zMeta.pct);
        const occ = Math.max(1, countOccurrencesPerWeek(tpl, mvId, zKey));
        const basePerExposure = Math.max(1, Math.ceil(weekTarget / occ));

        const used = appliedThisWeek(tpl, globalWeekIndex, mvId, zKey);
        const weekRemaining = Math.max(0, weekTarget - used);

        const targetToday = Math.min(remainingBlock, weekRemaining, basePerExposure);
        const plan = planForTarget(targetToday, ladder);

        const entry = ensureProgressEntry(globalWeekIndex, sessionIdx, idx);

        // clamp if plan changed
        entry.doneLadders = Math.min(entry.doneLadders||0, plan.fullLadders);
        if (!plan.leftoverTotal) entry.leftoverDone = false;

        const title = `${movementLabel(mvId)}: ${spec.exercise || "—"}`;
        const ladderText = `${ladder.a}-${ladder.b}-${ladder.C} × ${plan.fullLadders}`;
        const leftoverText = plan.leftoverTotal ? ` + leftover ${plan.leftoverTotal}` : "";

        const item = document.createElement("div");
        item.className = "item";
        item.innerHTML = `
          <div class="itemTop">
            <div class="name">
              ${esc(title)}
              <span class="sub muted">${esc(spec.load || "")}</span>
            </div>
          </div>
          <div class="line">
            <div class="mono">${esc(ladderText + leftoverText)}</div>
            <div class="ctrl">
              <button class="cbtn" data-dec>−</button>
              <span class="cval">${entry.doneLadders||0}/${plan.fullLadders}</span>
              <button class="cbtn" data-inc>+</button>
              ${plan.leftoverTotal ? `<button class="ltog ${entry.leftoverDone?'done':''}" data-ltog>+L</button>` : ``}
            </div>
          </div>
        `;
        zoneDiv.appendChild(item);

        item.querySelector("[data-inc]").onclick = () => {
          const next = Math.min(plan.fullLadders, (entry.doneLadders||0)+1);
          updateProgressAndRemaining(globalWeekIndex, sessionIdx, idx, mvId, zKey, ladder, plan.fullLadders, plan.leftoverTotal, next, entry.leftoverDone);
          renderPlanner();
        };
        item.querySelector("[data-dec]").onclick = () => {
          const next = Math.max(0, (entry.doneLadders||0)-1);
          updateProgressAndRemaining(globalWeekIndex, sessionIdx, idx, mvId, zKey, ladder, plan.fullLadders, plan.leftoverTotal, next, entry.leftoverDone);
          renderPlanner();
        };
        const lt = item.querySelector("[data-ltog]");
        if (lt){
          lt.onclick = () => {
            const next = !entry.leftoverDone;
            updateProgressAndRemaining(globalWeekIndex, sessionIdx, idx, mvId, zKey, ladder, plan.fullLadders, plan.leftoverTotal, entry.doneLadders||0, next);
            renderPlanner();
          };
        }
      }

      wrap.appendChild(zoneDiv);
    }

    saveState();
  }

  function renderCustom(){
    const tpl=TEMPLATES[state.template];
    $("#customHint").textContent = `Template ${tpl.name}: ${tpl.movements.length} movements × 3 zones = ${tpl.movements.length*3} slots.`;

    const wrap=$("#customWrap");
    wrap.innerHTML="";

    for (const mv of tpl.movements){
      const card=document.createElement("div");
      card.className="card setupCard";
      card.innerHTML = `<h3>${esc(mv.label)}</h3>`;

      for (const z of ZONES){
        const spec = state.stacks[mv.id][z.key];
        const ladder = buildLadder(spec.repMax);

        const row=document.createElement("div");
        row.className="setupRow";
        row.innerHTML = `
          <div class="pill">${z.key} — ${z.name} (${z.range})</div>
          <input type="text" data-k="ex" placeholder="Exercise name" value="${esc(spec.exercise||"")}">
          <input type="text" data-k="load" placeholder="Load (e.g. 24 kg / BW)" value="${esc(spec.load||"")}">
          <input type="number" min="1" step="1" data-k="rm" value="${Number(spec.repMax||10)}">
          <div class="muted mono">${ladder.a}-${ladder.b}-${ladder.C}</div>
        `;

        const ex=row.querySelector('input[data-k="ex"]');
        const ld=row.querySelector('input[data-k="load"]');
        const rm=row.querySelector('input[data-k="rm"]');

        ex.addEventListener("input",()=>{spec.exercise=ex.value; saveState(); renderPlanner();});
        ld.addEventListener("input",()=>{spec.load=ld.value; saveState(); renderPlanner();});
        rm.addEventListener("input",()=>{spec.repMax=Math.max(1,Number(rm.value)||1); saveState(); renderCustom(); renderPlanner();});

        card.appendChild(row);
      }

      wrap.appendChild(card);
    }
  }

  function resetThisSession(){
    const tpl=TEMPLATES[state.template];
    const sPerWeek = tpl.sessions.length;
    const cursor = state.sessionCursor|0;
    const globalWeekIndex = Math.floor(cursor / sPerWeek);
    const sIdx = mod(cursor, sPerWeek);
    const session = tpl.sessions[sIdx];

    session.blocks.forEach((blk, bi)=>{
      const key = progressKey(globalWeekIndex, sIdx, bi);
      const entry = state.progress[key];
      if (!entry) return;
      applyDeltaToRemaining(blk.movement, blk.zone, -(entry.appliedReps||0));
      delete state.progress[key];
    });
    saveState();
  }

  function clearAll(){
    state.progress = {};
    state.remaining = {};
    ensureRemaining(state);
    saveState();
  }

  function newBlock(){
    state.progress = {};
    state.remaining = {};
    state.sessionCursor = 0;
    ensureRemaining(state);
    saveState();
  }

  function applyTemplateAndVolume(templateKey, volume){
    const changed = templateKey !== state.template;

    state.template = templateKey;
    state.blockVolume = Number(volume)||300;

    if (changed){
      state.sessionCursor = 0;
      state.stacks = buildDefaultStacks(templateKey);
    }

    state.progress = {};
    state.remaining = {};
    ensureRemaining(state);

    saveState();
    $("#selTemplate").value = state.template;
    $("#selVol").value = String(state.blockVolume);
    renderCustom();
    renderPlanner();
  }

  // Tabs
  document.querySelectorAll(".tab").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const t = btn.dataset.tab;
      document.querySelectorAll(".tab").forEach(b=>b.classList.toggle("active", b===btn));
      document.querySelectorAll(".pane").forEach(p=>p.classList.toggle("active", p.id==="pane-"+t));
    });
  });

  // Controls wiring
  $("#selTemplate").value = state.template;
  $("#selVol").value = String(state.blockVolume);

  $("#selTemplate").addEventListener("change",()=>applyTemplateAndVolume($("#selTemplate").value, $("#selVol").value));
  $("#selVol").addEventListener("change",()=>applyTemplateAndVolume($("#selTemplate").value, $("#selVol").value));

  $("#btnPrev").onclick = ()=>{ state.sessionCursor -= 1; saveState(); renderPlanner(); };
  $("#btnNext").onclick = ()=>{ state.sessionCursor += 1; saveState(); renderPlanner(); };
  $("#btnResetSession").onclick = ()=>{ resetThisSession(); renderPlanner(); };

  $("#btnNewBlock").onclick = ()=>{ newBlock(); renderPlanner(); };
  $("#btnClearAll").onclick = ()=>{ clearAll(); renderPlanner(); };

  $("#btnSaveCustom").onclick = ()=>{ saveState(); alert("Saved."); };
  $("#btnResetCustom").onclick = ()=>{
    if (!confirm("Reset custom exercises for this template?")) return;
    state.stacks = buildDefaultStacks(state.template);
    saveState();
    renderCustom();
    renderPlanner();
  };

  // init
  ensureRemaining(state);
  renderCustom();
  renderPlanner();
})();
</script>
</body>
</html>
