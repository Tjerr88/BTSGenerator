<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>BuildStrong + PlanStrong — Unity Style</title>
<style>
  :root{color-scheme:dark}
  *{box-sizing:border-box}
  body{margin:0;background:#0b1220;color:#e6eaf2;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .app{max-width:980px;margin:0 auto;padding:16px 12px 96px}
  h1{margin:0 0 6px;font-size:28px}
  h2{margin:0;font-size:18px}
  .muted{opacity:.75;font-size:12px}

  .tabs{display:flex;gap:8px;margin:10px 0 12px;flex-wrap:wrap}
  .tab{
    flex:1;min-width:120px;cursor:pointer;
    background:#101a30;border:1px solid rgba(255,255,255,.14);color:#e6eaf2;
    padding:12px;border-radius:12px;font-weight:900
  }
  .tab.active{background:#2b63ff;border-color:#2b63ff}
  .pane{display:none}
  .pane.active{display:block}

  .card{background:#101a30;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;margin:10px 0}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .row.stack{display:flex}
  @media (max-width:760px){ .row.stack{display:grid;grid-template-columns:1fr;gap:8px} }

  .btn{
    background:#2b63ff;border:0;color:#fff;padding:12px 14px;border-radius:12px;
    cursor:pointer;font-weight:900
  }
  .btn.ghost{background:#0f1a34;border:1px solid rgba(255,255,255,.16)}
  .btn:active{transform:translateY(1px)}

  label{font-size:12px;opacity:.85;display:block;margin:8px 0 4px}
  select,input[type="text"],input[type="number"]{
    width:100%;background:#0d1830;border:1px solid rgba(255,255,255,.18);
    color:#e6eaf2;padding:10px;border-radius:10px
  }

  .sessionHead{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .meta{display:flex;gap:8px;flex-wrap:wrap}
  .pill{display:inline-flex;gap:8px;align-items:center;background:#182446;border-radius:999px;padding:6px 12px;font-size:12px}

  .zone{margin-top:12px}
  .zoneTitle{
    display:flex;justify-content:space-between;gap:10px;align-items:center;
    border-top:1px solid rgba(255,255,255,.12);
    padding-top:10px;margin-top:10px
  }
  .zoneTitle b{font-size:14px}
  .zoneTitle span{font-size:12px;opacity:.8}

  .item{background:#0e182c;border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px;margin:8px 0}
  .itemTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
  .name{font-weight:950;min-width:0}
  .sub{display:block;margin-top:2px;font-weight:750;opacity:.88}
  .line{margin-top:8px;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;opacity:.95}

  .ctrl{display:inline-flex;gap:8px;align-items:center}
  .cbtn{
    background:#0f1a34;border:1px solid rgba(255,255,255,.22);color:#e6eaf2;
    border-radius:10px;padding:6px 10px;font-weight:950;cursor:pointer
  }
  .cval{min-width:90px;text-align:center;font-weight:950}
  .ltog{
    background:#182446;border:1px solid rgba(255,255,255,.18);color:#e6eaf2;
    border-radius:10px;padding:6px 10px;font-weight:950;cursor:pointer
  }
  .ltog.done{background:#2b63ff;border-color:#2b63ff}

  .grid{display:grid;gap:10px}
  .cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  @media (max-width:760px){ .cols-2{grid-template-columns:1fr} }

  .setupCard h3{margin:0 0 10px;font-size:16px}
  .setupRow{
    display:grid;grid-template-columns:160px 1fr 140px 120px 160px;
    gap:10px;align-items:center;margin:10px 0
  }
  @media (max-width:760px){ .setupRow{grid-template-columns:1fr;gap:8px} }

  .setupRowPS{
    display:grid;grid-template-columns:160px 1fr 1fr 1fr 1fr;
    gap:10px;align-items:center;margin:10px 0
  }
  @media (max-width:760px){ .setupRowPS{grid-template-columns:1fr;gap:8px} }

  details{border:1px solid rgba(255,255,255,.08);border-radius:12px;background:#0f1a34}
  summary{list-style:none;cursor:pointer;padding:12px;font-weight:950}
  summary::-webkit-details-marker{display:none}
  details[open]>summary{border-bottom:1px solid rgba(255,255,255,.10)}
  .panel{padding:12px}
</style>
</head>
<body>
<div class="app">
  <h1>BuildStrong</h1>

  <div class="tabs">
    <button class="tab active" data-tab="planner">Planner</button>
    <button class="tab" data-tab="custom">Custom exercises</button>
    <button class="tab" data-tab="settings">Settings</button>
  </div>

  <!-- PLANNER -->
  <div class="pane active" id="pane-planner">
    <div class="row stack" style="margin:8px 0 12px">
      <button class="btn ghost" id="btnPrev">◀ Prev</button>
      <button class="btn" id="btnNext">Next ▶</button>
      <button class="btn ghost" id="btnResetSession">Reset session</button>
    </div>

    <div class="card">
      <div class="sessionHead">
        <div>
          <h2 id="headTitle">Week 1 • Session 1</h2>
          <div class="muted" id="headSub">—</div>
        </div>
        <div class="meta" id="kpi"></div>
      </div>
      <div id="planWrap"></div>
    </div>
  </div>

  <!-- CUSTOM EXERCISES -->
  <div class="pane" id="pane-custom">
    <div class="card">
      <h2>Custom exercises</h2>
      <div class="muted" id="customHint"></div>
    </div>
    <div id="customWrap"></div>
    <div class="card">
      <div class="row stack">
        <button class="btn" id="btnSaveCustom">Save</button>
        <button class="btn ghost" id="btnResetCustom">Reset custom exercises</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS -->
  <div class="pane" id="pane-settings">
    <div class="card">
      <h2>Settings</h2>

      <div class="grid cols-2" style="margin-top:8px">
        <div>
          <label>Template</label>
          <select id="selTemplate">
            <option value="BTS3">BTS3</option>
            <option value="BTS4">BTS4</option>
            <option value="BTS6" selected>BTS6</option>
            <option value="PS4">PS4</option>
            <option value="PSA">PS-A (Advanced)</option>
          </select>
        </div>
        <div>
          <label>Block volume</label>
          <select id="selVol">
            <option>200</option>
            <option>240</option>
            <option selected>300</option>
            <option>360</option>
            <option>420</option>
          </select>
        </div>
      </div>

      <details style="margin-top:12px" open>
        <summary>Rules</summary>
        <div class="panel muted" id="rulesText"></div>
      </details>

      <div class="row stack" style="margin-top:12px">
        <button class="btn" id="btnNewBlock">New block</button>
        <button class="btn ghost" id="btnClearAll">Clear all progress</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const LS_KEY = "BUILDS+PLANSTRONG_UNITYSTYLE_V1";

  // 4-week wave (both systems)
  const WEEK_WAVE = [
    { pct: 0.15, name: "Deload" },
    { pct: 0.28, name: "Development" },
    { pct: 0.22, name: "Maintenance" },
    { pct: 0.35, name: "Stress" },
  ];

  // BuildStrong zones (BTS)
  const BTS_ZONES = [
    { key:"H", name:"Heavy",  range:"4–7",   pct:0.15 },
    { key:"M", name:"Medium", range:"8–11",  pct:0.35 },
    { key:"L", name:"Light",  range:"12–15", pct:0.50 },
  ];

  // PlanStrong intensity anchors (rep-ranges)
  const PS_RANGES = {
    L: "8–12 RM",
    M: "5–7 RM",
    H: "3–4 RM",
    SH:"2–3 RM"
  };

  // PlanStrong session-position split inside a week (per lift):
  // in a given week, each lift gets 15% once, 35% once, 50% once
  const PS_SESSION_POS = [
    { key:"P15", name:"Lift 1", pct:0.15 },
    { key:"P35", name:"Lift 2", pct:0.35 },
    { key:"P50", name:"Lift 3", pct:0.50 },
  ];

  // PlanStrong intensity splits (per session per lift)
  const PS4_SPLIT = [
    { key:"L",  pct:0.50 },
    { key:"M",  pct:0.35 },
    { key:"H",  pct:0.15 },
  ];
  const PSA_SPLIT = [
    { key:"SH", pct:0.05 }, // capped 1 rep per ladder
    { key:"H",  pct:0.12 },
    { key:"M",  pct:0.34 },
    { key:"L",  pct:0.49 },
  ];

  const TEMPLATES = {
    // ===== BuildStrong (BTS) =====
    BTS3: {
      type:"BTS",
      name:"BTS3",
      movements:[
        {id:"push",  label:"Push"},
        {id:"pull",  label:"Pull"},
        {id:"lower", label:"Lower"},
      ],
      sessions:[
        { title:"Push Day",  blocks:[ {movement:"push",zone:"H"},{movement:"push",zone:"M"},{movement:"push",zone:"L"} ] },
        { title:"Pull Day",  blocks:[ {movement:"pull",zone:"H"},{movement:"pull",zone:"M"},{movement:"pull",zone:"L"} ] },
        { title:"Lower Day", blocks:[ {movement:"lower",zone:"H"},{movement:"lower",zone:"M"},{movement:"lower",zone:"L"} ] },
      ],
    },

    BTS4: {
      type:"BTS",
      name:"BTS4",
      movements:[
        {id:"push",  label:"Push"},
        {id:"pull",  label:"Pull"},
        {id:"squat", label:"Squat"},
        {id:"hinge", label:"Hinge"},
      ],
      sessions:[
        { title:"Full Body", blocks:[
          {movement:"squat",zone:"H"},
          {movement:"push",zone:"M"},{movement:"pull",zone:"M"},
          {movement:"hinge",zone:"L"},
        ]},
        { title:"Full Body", blocks:[
          {movement:"push",zone:"H"},{movement:"pull",zone:"H"},
          {movement:"hinge",zone:"M"},
          {movement:"squat",zone:"L"},
        ]},
        { title:"Full Body", blocks:[
          {movement:"hinge",zone:"H"},
          {movement:"squat",zone:"M"},
          {movement:"push",zone:"L"},{movement:"pull",zone:"L"},
        ]},
      ],
    },

    BTS6: {
      type:"BTS",
      name:"BTS6",
      movements:[
        {id:"pushHor", label:"Push Horizontal"},
        {id:"pullHor", label:"Pull Horizontal"},
        {id:"pushVer", label:"Push Vertical"},
        {id:"pullVer", label:"Pull Vertical"},
        {id:"squat",   label:"Squat"},
        {id:"hinge",   label:"Hinge"},
      ],
      sessions:[
        { title:"Upper A", blocks:[
          {movement:"pushHor",zone:"H"},{movement:"pullHor",zone:"H"},
          {movement:"pushVer",zone:"M"},{movement:"pullVer",zone:"M"},
          {movement:"pushHor",zone:"L"},{movement:"pullHor",zone:"L"},
        ]},
        { title:"Lower A", blocks:[
          {movement:"squat",zone:"H"},{movement:"hinge",zone:"M"},{movement:"squat",zone:"L"},
        ]},
        { title:"Upper B", blocks:[
          {movement:"pushVer",zone:"H"},{movement:"pullVer",zone:"H"},
          {movement:"pushHor",zone:"M"},{movement:"pullHor",zone:"M"},
          {movement:"pushVer",zone:"L"},{movement:"pullVer",zone:"L"},
        ]},
        { title:"Lower B", blocks:[
          {movement:"hinge",zone:"H"},{movement:"squat",zone:"M"},{movement:"hinge",zone:"L"},
        ]},
      ],
    },

    // ===== PlanStrong (PS) =====
    PS4: {
      type:"PS",
      name:"PS4",
      lifts:[
        {id:"squat", label:"Squat"},
        {id:"hinge", label:"Hinge"},
        {id:"push",  label:"Push"},
        {id:"pull",  label:"Pull"},
      ],
      ladders:3,
      split:PS4_SPLIT,
      // 3 sessions/week. Each session has 3 slots (15/35/50 of the week's reps for that lift).
      // Upper is always present, but it's push and pull separately and both take the session-slot pct.
      sessions:[
        { title:"Session 1", slots:[
          {lift:"squat", pos:"P15"},
          {lift:"upper", pos:"P35"}, // expands to push+pull
          {lift:"hinge", pos:"P50"},
        ]},
        { title:"Session 2", slots:[
          {lift:"upper", pos:"P15"},
          {lift:"hinge", pos:"P35"},
          {lift:"squat", pos:"P50"},
        ]},
        { title:"Session 3", slots:[
          {lift:"hinge", pos:"P15"},
          {lift:"squat", pos:"P35"},
          {lift:"upper", pos:"P50"},
        ]},
      ],
    },

    PSA: {
      type:"PS",
      name:"PS-A",
      lifts:[
        {id:"squat", label:"Squat"},
        {id:"hinge", label:"Hinge"},
        {id:"push",  label:"Push"},
        {id:"pull",  label:"Pull"},
      ],
      ladders:4,
      split:PSA_SPLIT,
      sessions:[
        { title:"Session 1", slots:[
          {lift:"squat", pos:"P15"},
          {lift:"upper", pos:"P35"},
          {lift:"hinge", pos:"P50"},
        ]},
        { title:"Session 2", slots:[
          {lift:"upper", pos:"P15"},
          {lift:"hinge", pos:"P35"},
          {lift:"squat", pos:"P50"},
        ]},
        { title:"Session 3", slots:[
          {lift:"hinge", pos:"P15"},
          {lift:"squat", pos:"P35"},
          {lift:"upper", pos:"P50"},
        ]},
      ],
    },
  };

  const $ = (s) => document.querySelector(s);
  const esc = (s) => String(s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const mod = (n,m)=>((n%m)+m)%m;

  // ===== BuildStrong (BTS) ladder rules =====
  function capC(repMax){ return Math.max(1, Math.floor(0.66 * (Number(repMax)||1))); }

  // choose a+b=C with delta20 between a and b (fallback if needed)
  function pickAB(C){
    const candidates=[];
    for (let a=1;a<=C-1;a++){
      const b=C-a;
      const delta=Math.abs(a-b)/Math.max(a,b);
      if (delta>=0.20) candidates.push({a,b});
    }
    if (!candidates.length) return {a:1,b:Math.max(1,C-1)};
    candidates.sort((x,y)=>{
      const rx=Math.max(x.a,x.b)/Math.max(1,Math.min(x.a,x.b));
      const ry=Math.max(y.a,y.b)/Math.max(1,Math.min(y.a,y.b));
      if (rx!==ry) return rx-ry;
      return y.a-x.a;
    });
    const best=candidates[0];
    return {a:Math.min(best.a,best.b), b:Math.max(best.a,best.b)};
  }

  function buildBTSLadder(repMax){
    const C=capC(repMax);
    const ab=pickAB(C);
    return {a:ab.a,b:ab.b,C,volume:ab.a+ab.b+C};
  }

  // leftover can be done as a single chunk <=C (simple, "clients don't need to know")
  function planBTS(targetReps, ladder){
    const t = Math.max(0, targetReps|0);
    const full = ladder.volume>0 ? Math.floor(t/ladder.volume) : 0;
    const leftover = ladder.volume>0 ? (t % ladder.volume) : t;
    const leftoverClamped = Math.min(ladder.C, leftover);
    return { fullLadders: full, leftoverTotal: leftoverClamped };
  }

  // ===== PlanStrong (PS) planning =====

  // Robust integer allocation with constraints and "fill SH"
  function allocByPerc(total, split, opts={}){
    const items = split.map(s=>({key:s.key, pct:s.pct, raw:total*s.pct, base:Math.floor(total*s.pct), frac:(total*s.pct)%1}));
    let used = items.reduce((a,x)=>a+x.base,0);
    let rem = total - used;

    // optional SH min=1 when total>0
    if (opts.minKey && total>0){
      const it = items.find(x=>x.key===opts.minKey);
      if (it && it.base===0){
        it.base = 1; rem -= 1;
      }
    }

    // optional max caps
    const maxMap = opts.maxMap || {};

    // distribute remainder by largest fractional first
    items.sort((a,b)=>b.frac-a.frac);
    let i=0;
    while (rem>0 && i<10000){
      const it = items[i % items.length];
      const cap = (maxMap[it.key] ?? Infinity);
      if (it.base < cap){
        it.base += 1;
        rem -= 1;
      }
      i++;
      // if we loop too long due to caps, break
      if (i>items.length*20 && rem>0){
        // dump remainder into last non-capped (prefer L)
        const pref = items.find(x=>x.key==="L") || items[0];
        const cap2 = (maxMap[pref.key] ?? Infinity);
        if (pref.base < cap2){ pref.base += 1; rem -= 1; }
        else break;
      }
    }

    // if rem went negative (due to minKey), pull back from largest buckets (prefer L then M)
    if (rem<0){
      const order = ["L","M","H","SH"];
      for (const k of order){
        const it = items.find(x=>x.key===k);
        while (it && it.base>0 && rem<0 && (opts.minKey!==k || it.base>1)){
          it.base -= 1;
          rem += 1;
        }
      }
    }

    const out={};
    for (const it of items) out[it.key]=it.base;
    return out;
  }

  function splitAcrossLadders(total, ladders){
    const base = Math.floor(total / ladders);
    const rem = total % ladders;
    const arr = Array.from({length:ladders}, (_,i)=>base + (i<rem ? 1 : 0)); // remainder front-loaded
    return arr;
  }

  // Plan one PS lift instance: returns ladder lines and reps-per-ladder
  function planPSLift(sessionReps, templateKey){
    const tpl = TEMPLATES[templateKey];
    const ladders = tpl.ladders;
    const split = tpl.split;

    // SH caps: max 1 per ladder (so total SH <= ladders)
    const maxMap = {};
    if (templateKey==="PSA"){
      maxMap["SH"] = ladders;
    }

    // Ensure SH "filled" (min 1 if sessionReps>0)
    const totals = allocByPerc(sessionReps, split, templateKey==="PSA"
      ? {minKey:"SH", maxMap}
      : {});

    // Build per-ladder counts
    const per = {};
    for (const k of Object.keys(totals)){
      per[k] = splitAcrossLadders(totals[k], ladders);
    }

    // Apply SH cap 1 per ladder (if any)
    if (templateKey==="PSA"){
      // force SH as 1s in first ladders until totals.SH
      const sh = totals["SH"] || 0;
      per["SH"] = Array.from({length:ladders}, (_,i)=> (i<sh ? 1 : 0));
      // recompute L to fix sum back to sessionReps
      const sumOther = ["H","M","SH"].reduce((a,k)=>a + (per[k]?per[k].reduce((x,y)=>x+y,0):0), 0);
      const Lneeded = Math.max(0, sessionReps - sumOther);
      per["L"] = splitAcrossLadders(Lneeded, ladders);
    }

    const lines=[];
    const repsPerLadder=[];
    for (let i=0;i<ladders;i++){
      const L = (per["L"]?.[i] ?? 0);
      const M = (per["M"]?.[i] ?? 0);
      const H = (per["H"]?.[i] ?? 0);
      const SH= (per["SH"]?.[i] ?? 0);
      const line = (tpl.name==="PS-A")
        ? `${L}-${M}-${H}-${SH}`
        : `${L}-${M}-${H}`;
      lines.push(line);
      repsPerLadder.push(L+M+H+SH);
    }
    return {lines, repsPerLadder, totals};
  }

  // Week reps per lift in PS: weekVolume = blockVolume * weekWavePct (example: 300*0.15=45)
  // Session reps per lift: split weekVolume into [15,35,50]% by rounding + remainder fix
  function splitWeekIntoSessions(weekVolume){
    const raw = PS_SESSION_POS.map(p=>weekVolume*p.pct);
    const base = raw.map(x=>Math.floor(x));
    let used = base.reduce((a,b)=>a+b,0);
    let rem = weekVolume - used;
    // distribute remainder to largest fractional
    const fr = raw.map((x,i)=>({i, frac:x - Math.floor(x)})).sort((a,b)=>b.frac-a.frac);
    let j=0;
    while (rem>0){
      base[fr[j%fr.length].i] += 1;
      rem--;
      j++;
    }
    return {P15:base[0], P35:base[1], P50:base[2]};
  }

  // ===== State =====

  function buildDefaultStacksBTS(templateKey){
    const tpl=TEMPLATES[templateKey];
    const stacks={};
    for (const mv of tpl.movements){
      stacks[mv.id] = {
        H:{exercise:"",load:"",repMax:5},
        M:{exercise:"",load:"",repMax:10},
        L:{exercise:"",load:"",repMax:15},
      };
    }
    return stacks;
  }

  function buildDefaultStacksPS(){
    return {
      squat:{exercise:"", loadL:"", loadM:"", loadH:"", loadSH:""},
      hinge:{exercise:"", loadL:"", loadM:"", loadH:"", loadSH:""},
      push: {exercise:"", loadL:"", loadM:"", loadH:"", loadSH:""},
      pull: {exercise:"", loadL:"", loadM:"", loadH:"", loadSH:""},
    };
  }

  function defaultState(){
    return {
      template:"BTS6",
      blockVolume:300,
      sessionCursor:0,

      // BTS
      btsStacks: buildDefaultStacksBTS("BTS6"),
      btsRemaining:{}, // per movement per zone (block-level)
      btsProgress:{},

      // PS
      psStacks: buildDefaultStacksPS(),
      psRemaining:{},  // per lift total remaining reps for full block (blockVolume)
      psProgress:{},   // per session per lift: laddersDone + appliedReps
    };
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return initState(defaultState());
      const st = JSON.parse(raw);
      return initState(st);
    }catch(e){
      console.error(e);
      return initState(defaultState());
    }
  }

  function saveState(){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function initState(st){
    if (!st.template) st.template="BTS6";
    if (!st.blockVolume) st.blockVolume=300;
    if (typeof st.sessionCursor!=="number") st.sessionCursor=0;

    if (!st.btsStacks) st.btsStacks = buildDefaultStacksBTS(st.template.startsWith("BTS") ? st.template : "BTS6");
    if (!st.btsRemaining) st.btsRemaining={};
    if (!st.btsProgress) st.btsProgress={};

    if (!st.psStacks) st.psStacks = buildDefaultStacksPS();
    if (!st.psRemaining) st.psRemaining={};
    if (!st.psProgress) st.psProgress={};

    // ensure BTS stacks for template
    if (TEMPLATES[st.template]?.type==="BTS"){
      const tpl=TEMPLATES[st.template];
      for (const mv of tpl.movements){
        if (!st.btsStacks[mv.id]){
          st.btsStacks[mv.id]={H:{exercise:"",load:"",repMax:5},M:{exercise:"",load:"",repMax:10},L:{exercise:"",load:"",repMax:15}};
        }
      }
      ensureBTSRemaining(st);
    }

    // ensure PS remaining
    if (TEMPLATES[st.template]?.type==="PS"){
      ensurePSRemaining(st);
    }
    return st;
  }

  let state = loadState();

  // ===== BTS remaining/progress =====
  function btsZoneTargets(blockVolume){
    const out={};
    for (const z of BTS_ZONES) out[z.key]=Math.round(Number(blockVolume)*z.pct);
    return out;
  }

  function ensureBTSRemaining(st){
    const tpl=TEMPLATES[st.template];
    const tgt=btsZoneTargets(st.blockVolume);
    st.btsRemaining = st.btsRemaining || {};
    for (const mv of tpl.movements){
      st.btsRemaining[mv.id] = st.btsRemaining[mv.id] || {};
      for (const z of BTS_ZONES){
        if (typeof st.btsRemaining[mv.id][z.key] !== "number") st.btsRemaining[mv.id][z.key] = tgt[z.key];
      }
    }
  }

  function btsProgressKey(globalWeekIndex, sessionIndex, blockIndex){
    return `${state.template}|v${state.blockVolume}|w${globalWeekIndex}|s${sessionIndex}|b${blockIndex}`;
  }

  function btsCountOccurrencesPerWeek(tpl, movementId, zoneKey){
    let n=0;
    for (const s of tpl.sessions){
      for (const b of s.blocks){
        if (b.movement===movementId && b.zone===zoneKey) n++;
      }
    }
    return n;
  }

  function btsWeekZoneTarget(blockVolume, phasePct, zonePct){
    return Math.round(Number(blockVolume) * phasePct * zonePct);
  }

  function btsAppliedThisWeek(tpl, globalWeekIndex, movementId, zoneKey){
    let total=0;
    for (let sIdx=0; sIdx<tpl.sessions.length; sIdx++){
      const session = tpl.sessions[sIdx];
      session.blocks.forEach((blk, bi)=>{
        if (blk.movement!==movementId || blk.zone!==zoneKey) return;
        const key = btsProgressKey(globalWeekIndex, sIdx, bi);
        const entry = state.btsProgress[key];
        if (entry && typeof entry.appliedReps==="number") total += entry.appliedReps;
      });
    }
    return total;
  }

  function btsEnsureEntry(globalWeekIndex, sessionIndex, blockIndex){
    const key=btsProgressKey(globalWeekIndex, sessionIndex, blockIndex);
    if (!state.btsProgress[key]){
      state.btsProgress[key]={doneLadders:0,leftoverDone:false,appliedReps:0};
    }
    return state.btsProgress[key];
  }

  function btsComputeApplied(doneLadders, ladder, leftoverTotal, leftoverDone){
    return (doneLadders|0)*ladder.volume + (leftoverDone ? (leftoverTotal|0) : 0);
  }

  function btsApplyDeltaToRemaining(mvId, zKey, delta){
    const tgt = btsZoneTargets(state.blockVolume)[zKey];
    const cur = state.btsRemaining[mvId][zKey];
    let next = cur - delta;
    next = Math.max(0, Math.min(tgt, next));
    state.btsRemaining[mvId][zKey]=next;
  }

  function btsUpdate(globalWeekIndex, sessionIndex, blockIndex, mvId, zKey, ladder, planFull, leftoverTotal, newDone, newLeftDone){
    const key=btsProgressKey(globalWeekIndex, sessionIndex, blockIndex);
    const entry=state.btsProgress[key];

    newDone = Math.max(0, Math.min(planFull, newDone|0));
    newLeftDone = !!newLeftDone;

    const oldApplied = entry.appliedReps || 0;
    const nextApplied = btsComputeApplied(newDone, ladder, leftoverTotal, newLeftDone);
    const delta = nextApplied - oldApplied;

    if (delta>0){
      const remaining = state.btsRemaining[mvId][zKey];
      const allowed = Math.min(delta, remaining);
      btsApplyDeltaToRemaining(mvId, zKey, allowed);
      entry.appliedReps = oldApplied + allowed;
    } else if (delta<0){
      btsApplyDeltaToRemaining(mvId, zKey, delta); // negative adds back
      entry.appliedReps = nextApplied;
    }

    entry.doneLadders = newDone;
    entry.leftoverDone = newLeftDone;
    saveState();
  }

  // ===== PS remaining/progress =====
  function ensurePSRemaining(st){
    st.psRemaining = st.psRemaining || {};
    // each lift gets blockVolume reps across 4-week wave
    for (const lid of ["squat","hinge","push","pull"]){
      if (typeof st.psRemaining[lid] !== "number") st.psRemaining[lid] = Number(st.blockVolume)||300;
    }
  }

  function psKey(globalWeekIndex, sessionIndex, liftId){
    return `${state.template}|v${state.blockVolume}|w${globalWeekIndex}|s${sessionIndex}|lift${liftId}`;
  }

  function psEnsureEntry(globalWeekIndex, sessionIndex, liftId){
    const key=psKey(globalWeekIndex, sessionIndex, liftId);
    if (!state.psProgress[key]){
      state.psProgress[key]={laddersDone:0, appliedReps:0};
    }
    return state.psProgress[key];
  }

  function psUpdate(globalWeekIndex, sessionIndex, liftId, repsPerLadder, newDone){
    const tpl=TEMPLATES[state.template];
    const ladders=tpl.ladders;
    newDone = Math.max(0, Math.min(ladders, newDone|0));

    const key=psKey(globalWeekIndex, sessionIndex, liftId);
    const entry=state.psProgress[key];

    const oldApplied = entry.appliedReps || 0;
    const nextApplied = repsPerLadder.slice(0,newDone).reduce((a,b)=>a+b,0);
    let delta = nextApplied - oldApplied;

    if (delta>0){
      const remaining = state.psRemaining[liftId];
      const allowed = Math.min(delta, remaining);
      state.psRemaining[liftId] = Math.max(0, remaining - allowed);
      entry.appliedReps = oldApplied + allowed;

      // If we couldn't apply full delta due to remaining, clamp laddersDone down
      if (allowed < delta){
        // find max ladders we can afford
        let can=0, acc=0;
        for (let i=0;i<repsPerLadder.length;i++){
          if (acc + repsPerLadder[i] <= remaining){ acc += repsPerLadder[i]; can++; }
          else break;
        }
        entry.laddersDone = can;
        entry.appliedReps = oldApplied + acc;
        saveState();
        return;
      }
    } else if (delta<0){
      // add back
      state.psRemaining[liftId] = Math.min(state.blockVolume, state.psRemaining[liftId] + (-delta));
      entry.appliedReps = nextApplied;
    }

    entry.laddersDone = newDone;
    saveState();
  }

  // ===== UI helpers =====
  function blockDonePct(){
    const tpl=TEMPLATES[state.template];
    if (tpl.type==="BTS"){
      const targets=btsZoneTargets(state.blockVolume);
      let total=0, rem=0;
      for (const mv of tpl.movements){
        for (const z of BTS_ZONES){
          total += targets[z.key];
          rem += state.btsRemaining[mv.id][z.key];
        }
      }
      const done = total - rem;
      return total>0 ? Math.round((done/total)*100) : 0;
    } else {
      // PS: total block reps = blockVolume * 4 lifts
      const total = state.blockVolume * 4;
      const rem = ["squat","hinge","push","pull"].reduce((a,k)=>a+(state.psRemaining[k]||0),0);
      const done = total - rem;
      return total>0 ? Math.round((done/total)*100) : 0;
    }
  }

  function setRulesText(){
    const tpl=TEMPLATES[state.template];
    const el=$("#rulesText");
    if (tpl.type==="BTS"){
      el.innerHTML = `
        Week-wave: <b>15–28–22–35</b> (Deload / Development / Maintenance / Stress)<br/>
        Zone split (per week): <b>15% Heavy</b> / <b>35% Medium</b> / <b>50% Light</b><br/>
        Ladder: <b>C = floor(0.66 × RM)</b>, choose <b>a+b=C</b>, enforce <b>delta20</b> between a and b.<br/>
        Leftover is hidden; you tick <b>+L</b> to finish it.
      `;
    } else {
      const isA = state.template==="PSA";
      el.innerHTML = `
        Week-wave: <b>15–28–22–35</b><br/>
        Sessions/week: <b>3</b> • Each week each lift gets <b>15%</b>, <b>35%</b>, <b>50%</b> once.<br/>
        Intensities every session via ladders (order always <b>L → M → H${isA ? " → SH":""}</b>).<br/>
        ${isA
          ? `PS-A split: <b>SH 5%</b> (cap 1 rep per ladder), <b>H 12%</b>, <b>M 34%</b>, <b>L 49%</b> • Ladders/lift: <b>4</b><br/>`
          : `PS4 split: <b>L 50%</b>, <b>M 35%</b>, <b>H 15%</b> • Ladders/lift: <b>3</b><br/>`}
        Rep-ranges (anchors): L <b>${PS_RANGES.L}</b> • M <b>${PS_RANGES.M}</b> • H <b>${PS_RANGES.H}</b>${isA ? ` • SH <b>${PS_RANGES.SH}</b>`:""}
      `;
    }
  }

  // ===== Rendering =====
  function renderKPI(phaseName){
    const tpl=TEMPLATES[state.template];
    $("#kpi").innerHTML = [
      `<span class="pill">Template <b>${tpl.name}</b></span>`,
      `<span class="pill">Block <b>${state.blockVolume}</b></span>`,
      `<span class="pill">Week <b>${phaseName}</b></span>`,
      `<span class="pill">Progress <b>${blockDonePct()}%</b></span>`
    ].join("");
  }

  function renderPlanner(){
    const tpl=TEMPLATES[state.template];
    setRulesText();

    const wrap=$("#planWrap");
    wrap.innerHTML="";

    // compute week/session
    const sessionsPerWeek = tpl.type==="BTS" ? tpl.sessions.length : tpl.sessions.length;
    const cursor = state.sessionCursor|0;
    const globalWeekIndex = Math.floor(cursor / sessionsPerWeek);
    const week = globalWeekIndex + 1;
    const phase = WEEK_WAVE[mod(globalWeekIndex, WEEK_WAVE.length)];
    const sessionIdx = mod(cursor, sessionsPerWeek);

    $("#headTitle").textContent = `Week ${week} • Session ${sessionIdx+1}`;
    $("#headSub").textContent = `${tpl.name} • ${tpl.type==="BTS" ? tpl.sessions[sessionIdx].title : tpl.sessions[sessionIdx].title} • ${phase.name}`;
    renderKPI(phase.name);

    if (tpl.type==="BTS"){
      ensureBTSRemaining(state);

      const session = tpl.sessions[sessionIdx];
      const byZone = {H:[],M:[],L:[]};
      session.blocks.forEach((b,i)=>byZone[b.zone].push({blk:b, idx:i}));

      for (const zKey of ["H","M","L"]){
        const zMeta = BTS_ZONES.find(z=>z.key===zKey);

        const zoneDiv=document.createElement("div");
        zoneDiv.className="zone";
        zoneDiv.innerHTML = `<div class="zoneTitle"><b>${zMeta.name}</b><span>${zMeta.range}</span></div>`;

        for (const {blk, idx} of byZone[zKey]){
          const mvId=blk.movement;
          const spec = state.btsStacks[mvId][zKey];
          const ladder = buildBTSLadder(spec.repMax);

          // budgets
          const remainingBlock = Math.max(0, state.btsRemaining[mvId][zKey]);
          const weekTarget = btsWeekZoneTarget(state.blockVolume, phase.pct, zMeta.pct);
          const occ = Math.max(1, btsCountOccurrencesPerWeek(tpl, mvId, zKey));
          const perExposure = Math.max(1, Math.ceil(weekTarget / occ));
          const used = btsAppliedThisWeek(tpl, globalWeekIndex, mvId, zKey);
          const weekRemaining = Math.max(0, weekTarget - used);

          const targetToday = Math.min(remainingBlock, weekRemaining, perExposure);
          const plan = planBTS(targetToday, ladder);

          const entry = btsEnsureEntry(globalWeekIndex, sessionIdx, idx);
          entry.doneLadders = Math.min(entry.doneLadders||0, plan.fullLadders);
          if (!plan.leftoverTotal) entry.leftoverDone = false;

          const title = `${(tpl.movements.find(m=>m.id===mvId)?.label||mvId)}: ${spec.exercise || "—"}`;
          const ladderText = `${ladder.a}-${ladder.b}-${ladder.C} × ${plan.fullLadders}`;
          const leftoverText = plan.leftoverTotal ? ` + leftover ${plan.leftoverTotal}` : "";

          const item=document.createElement("div");
          item.className="item";
          item.innerHTML = `
            <div class="itemTop">
              <div class="name">
                ${esc(title)}
                <span class="sub muted">${esc(spec.load || "")}</span>
              </div>
            </div>
            <div class="line">
              <div class="mono">${esc(ladderText + leftoverText)}</div>
              <div class="ctrl">
                <button class="cbtn" data-dec>−</button>
                <span class="cval">${entry.doneLadders||0}/${plan.fullLadders}</span>
                <button class="cbtn" data-inc>+</button>
                ${plan.leftoverTotal ? `<button class="ltog ${entry.leftoverDone?'done':''}" data-ltog>+L</button>` : ``}
              </div>
            </div>
          `;
          zoneDiv.appendChild(item);

          item.querySelector("[data-inc]").onclick = () => {
            const next = Math.min(plan.fullLadders, (entry.doneLadders||0)+1);
            btsUpdate(globalWeekIndex, sessionIdx, idx, mvId, zKey, ladder, plan.fullLadders, plan.leftoverTotal, next, entry.leftoverDone);
            renderPlanner();
          };
          item.querySelector("[data-dec]").onclick = () => {
            const next = Math.max(0, (entry.doneLadders||0)-1);
            btsUpdate(globalWeekIndex, sessionIdx, idx, mvId, zKey, ladder, plan.fullLadders, plan.leftoverTotal, next, entry.leftoverDone);
            renderPlanner();
          };
          const lt=item.querySelector("[data-ltog]");
          if (lt){
            lt.onclick = () => {
              const next=!entry.leftoverDone;
              btsUpdate(globalWeekIndex, sessionIdx, idx, mvId, zKey, ladder, plan.fullLadders, plan.leftoverTotal, entry.doneLadders||0, next);
              renderPlanner();
            };
          }
        }
        wrap.appendChild(zoneDiv);
      }
      saveState();
      return;
    }

    // ===== PlanStrong planner =====
    ensurePSRemaining(state);

    const psSession = tpl.sessions[sessionIdx];
    const weekPerLift = Math.round(state.blockVolume * phase.pct); // e.g. 300*0.15=45
    const posMap = splitWeekIntoSessions(weekPerLift);            // {P15,P35,P50} integers

    // Render each slot in order (15/35/50 positions)
    psSession.slots.forEach((slot, slotIdx)=>{
      const pos = PS_SESSION_POS.find(p=>p.key===slot.pos);
      const sessionRepsForThatLift = posMap[slot.pos];

      const zoneDiv=document.createElement("div");
      zoneDiv.className="zone";
      zoneDiv.innerHTML = `<div class="zoneTitle"><b>${pos.name} (${Math.round(pos.pct*100)}%)</b><span>Target reps: ${sessionRepsForThatLift}</span></div>`;

      // expand Upper into push/pull
      const liftsToRender = (slot.lift==="upper") ? ["push","pull"] : [slot.lift];

      liftsToRender.forEach(liftId=>{
        const stack = state.psStacks[liftId] || {exercise:"",loadL:"",loadM:"",loadH:"",loadSH:""};
        const title = `${(tpl.lifts.find(x=>x.id===liftId)?.label||liftId)}: ${stack.exercise || "—"}`;

        // Cap by remaining (block level) — if remaining is low, clamp sessionReps
        const remaining = state.psRemaining[liftId] ?? state.blockVolume;
        const sessionReps = Math.min(sessionRepsForThatLift, remaining);

        const plan = planPSLift(sessionReps, state.template); // lines + repsPerLadder
        const entry = psEnsureEntry(globalWeekIndex, sessionIdx, liftId);
        const laddersTotal = tpl.ladders;
        entry.laddersDone = Math.min(entry.laddersDone||0, laddersTotal);

        // Loads shown as compact label
        const loadLine = (state.template==="PSA")
          ? `L(${PS_RANGES.L}): ${stack.loadL||"—"} • M(${PS_RANGES.M}): ${stack.loadM||"—"} • H(${PS_RANGES.H}): ${stack.loadH||"—"} • SH(${PS_RANGES.SH}): ${stack.loadSH||"—"}`
          : `L(${PS_RANGES.L}): ${stack.loadL||"—"} • M(${PS_RANGES.M}): ${stack.loadM||"—"} • H(${PS_RANGES.H}): ${stack.loadH||"—"}`;

        // Ladder lines compact
        const ladderText = plan.lines.map((ln,i)=>`${i+1}) ${ln}`).join("  |  ");

        const item=document.createElement("div");
        item.className="item";
        item.innerHTML = `
          <div class="itemTop">
            <div class="name">
              ${esc(title)}
              <span class="sub muted">${esc(loadLine)}</span>
            </div>
          </div>
          <div class="line">
            <div class="mono">${esc(ladderText)}</div>
            <div class="ctrl">
              <button class="cbtn" data-dec>−</button>
              <span class="cval">${entry.laddersDone||0}/${laddersTotal}</span>
              <button class="cbtn" data-inc>+</button>
            </div>
          </div>
        `;
        zoneDiv.appendChild(item);

        item.querySelector("[data-inc]").onclick = () => {
          const next = Math.min(laddersTotal, (entry.laddersDone||0)+1);
          psUpdate(globalWeekIndex, sessionIdx, liftId, plan.repsPerLadder, next);
          renderPlanner();
        };
        item.querySelector("[data-dec]").onclick = () => {
          const next = Math.max(0, (entry.laddersDone||0)-1);
          psUpdate(globalWeekIndex, sessionIdx, liftId, plan.repsPerLadder, next);
          renderPlanner();
        };
      });

      wrap.appendChild(zoneDiv);
    });

    saveState();
  }

  function renderCustom(){
    const tpl=TEMPLATES[state.template];
    const wrap=$("#customWrap");
    wrap.innerHTML="";

    if (tpl.type==="BTS"){
      $("#customHint").textContent = `BTS template: ${tpl.movements.length} movements × 3 zones = ${tpl.movements.length*3} slots.`;

      for (const mv of tpl.movements){
        const card=document.createElement("div");
        card.className="card setupCard";
        card.innerHTML = `<h3>${esc(mv.label)}</h3>`;

        for (const z of BTS_ZONES){
          const spec = state.btsStacks[mv.id][z.key];
          const ladder = buildBTSLadder(spec.repMax);

          const row=document.createElement("div");
          row.className="setupRow";
          row.innerHTML = `
            <div class="pill">${z.key} — ${z.name} (${z.range})</div>
            <input type="text" data-k="ex" placeholder="Exercise name" value="${esc(spec.exercise||"")}">
            <input type="text" data-k="load" placeholder="Load (e.g. 24 kg / BW)" value="${esc(spec.load||"")}">
            <input type="number" min="1" step="1" data-k="rm" value="${Number(spec.repMax||10)}">
            <div class="muted mono">${ladder.a}-${ladder.b}-${ladder.C}</div>
          `;
          const ex=row.querySelector('input[data-k="ex"]');
          const ld=row.querySelector('input[data-k="load"]');
          const rm=row.querySelector('input[data-k="rm"]');
          ex.addEventListener("input",()=>{spec.exercise=ex.value; saveState(); renderPlanner();});
          ld.addEventListener("input",()=>{spec.load=ld.value; saveState(); renderPlanner();});
          rm.addEventListener("input",()=>{spec.repMax=Math.max(1,Number(rm.value)||1); saveState(); renderCustom(); renderPlanner();});
          card.appendChild(row);
        }
        wrap.appendChild(card);
      }
      return;
    }

    // PS custom
    const isA = state.template==="PSA";
    $("#customHint").innerHTML = `PlanStrong: choose <b>4 lifts</b>. Anchors: L <b>${PS_RANGES.L}</b> • M <b>${PS_RANGES.M}</b> • H <b>${PS_RANGES.H}</b>${isA?` • SH <b>${PS_RANGES.SH}</b>`:""}.`;

    const lifts = TEMPLATES[state.template].lifts;
    for (const lf of lifts){
      const s = state.psStacks[lf.id];

      const card=document.createElement("div");
      card.className="card setupCard";
      card.innerHTML = `<h3>${esc(lf.label)}</h3>`;

      const row=document.createElement("div");
      row.className="setupRowPS";
      row.innerHTML = `
        <div class="pill">Exercise</div>
        <input type="text" data-k="ex" placeholder="${lf.label} exercise" value="${esc(s.exercise||"")}">
        <input type="text" data-k="L"  placeholder="Load L (${PS_RANGES.L})" value="${esc(s.loadL||"")}">
        <input type="text" data-k="M"  placeholder="Load M (${PS_RANGES.M})" value="${esc(s.loadM||"")}">
        <input type="text" data-k="H"  placeholder="Load H (${PS_RANGES.H})" value="${esc(s.loadH||"")}">
      `;
      card.appendChild(row);

      if (isA){
        const row2=document.createElement("div");
        row2.className="setupRowPS";
        row2.innerHTML = `
          <div class="pill">SH</div>
          <div class="muted" style="padding:10px 0">Super Heavy (cap 1 rep per ladder)</div>
          <input type="text" data-k="SH" placeholder="Load SH (${PS_RANGES.SH})" value="${esc(s.loadSH||"")}">
          <div></div><div></div>
        `;
        card.appendChild(row2);
      }

      // wire
      const ex=row.querySelector('input[data-k="ex"]');
      const l=row.querySelector('input[data-k="L"]');
      const m=row.querySelector('input[data-k="M"]');
      const h=row.querySelector('input[data-k="H"]');
      ex.addEventListener("input",()=>{s.exercise=ex.value; saveState(); renderPlanner();});
      l.addEventListener("input",()=>{s.loadL=l.value; saveState(); renderPlanner();});
      m.addEventListener("input",()=>{s.loadM=m.value; saveState(); renderPlanner();});
      h.addEventListener("input",()=>{s.loadH=h.value; saveState(); renderPlanner();});

      if (isA){
        const sh=card.querySelector('input[data-k="SH"]');
        sh.addEventListener("input",()=>{s.loadSH=sh.value; saveState(); renderPlanner();});
      }

      wrap.appendChild(card);
    }
  }

  // ===== Actions =====
  function resetThisSession(){
    const tpl=TEMPLATES[state.template];
    const sessionsPerWeek = tpl.sessions.length;
    const cursor=state.sessionCursor|0;
    const globalWeekIndex=Math.floor(cursor/sessionsPerWeek);
    const sessionIdx=mod(cursor, sessionsPerWeek);

    if (tpl.type==="BTS"){
      const session=tpl.sessions[sessionIdx];
      session.blocks.forEach((blk, bi)=>{
        const key=btsProgressKey(globalWeekIndex, sessionIdx, bi);
        const entry=state.btsProgress[key];
        if (!entry) return;
        btsApplyDeltaToRemaining(blk.movement, blk.zone, -(entry.appliedReps||0));
        delete state.btsProgress[key];
      });
    } else {
      // PS: reset ladders for lifts in this session
      const session=tpl.sessions[sessionIdx];
      const liftIds=[];
      session.slots.forEach(slot=>{
        if (slot.lift==="upper") liftIds.push("push","pull");
        else liftIds.push(slot.lift);
      });
      for (const liftId of liftIds){
        const key=psKey(globalWeekIndex, sessionIdx, liftId);
        const entry=state.psProgress[key];
        if (!entry) continue;
        // add back applied reps to remaining
        state.psRemaining[liftId] = Math.min(state.blockVolume, (state.psRemaining[liftId]||0) + (entry.appliedReps||0));
        delete state.psProgress[key];
      }
    }
    saveState();
  }

  function clearAll(){
    const tpl=TEMPLATES[state.template];
    if (tpl.type==="BTS"){
      state.btsProgress={};
      state.btsRemaining={};
      ensureBTSRemaining(state);
    } else {
      state.psProgress={};
      state.psRemaining={};
      ensurePSRemaining(state);
    }
    saveState();
  }

  function newBlock(){
    // clear progress + remaining and reset cursor
    state.sessionCursor=0;
    const tpl=TEMPLATES[state.template];
    if (tpl.type==="BTS"){
      state.btsProgress={};
      state.btsRemaining={};
      ensureBTSRemaining(state);
    } else {
      state.psProgress={};
      state.psRemaining={};
      ensurePSRemaining(state);
    }
    saveState();
  }

  function applyTemplateAndVolume(templateKey, volume){
    const changed = templateKey !== state.template;
    state.template = templateKey;
    state.blockVolume = Number(volume)||300;
    state.sessionCursor = 0;

    const tpl=TEMPLATES[state.template];

    if (tpl.type==="BTS"){
      // build stacks for this BTS template if needed
      state.btsStacks = buildDefaultStacksBTS(state.template);
      state.btsProgress = {};
      state.btsRemaining = {};
      ensureBTSRemaining(state);
    } else {
      // keep PS stacks; reset progress/remaining for new block volume
      state.psProgress = {};
      state.psRemaining = {};
      ensurePSRemaining(state);
    }

    saveState();
    setRulesText();
    renderCustom();
    renderPlanner();
  }

  // ===== Tabs =====
  document.querySelectorAll(".tab").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const t = btn.dataset.tab;
      document.querySelectorAll(".tab").forEach(b=>b.classList.toggle("active", b===btn));
      document.querySelectorAll(".pane").forEach(p=>p.classList.toggle("active", p.id==="pane-"+t));
    });
  });

  // ===== Wire UI =====
  $("#selTemplate").value = state.template;
  $("#selVol").value = String(state.blockVolume);

  $("#selTemplate").addEventListener("change",()=>applyTemplateAndVolume($("#selTemplate").value, $("#selVol").value));
  $("#selVol").addEventListener("change",()=>applyTemplateAndVolume($("#selTemplate").value, $("#selVol").value));

  $("#btnPrev").onclick = ()=>{ state.sessionCursor -= 1; saveState(); renderPlanner(); };
  $("#btnNext").onclick = ()=>{ state.sessionCursor += 1; saveState(); renderPlanner(); };
  $("#btnResetSession").onclick = ()=>{ resetThisSession(); renderPlanner(); };

  $("#btnNewBlock").onclick = ()=>{ newBlock(); renderPlanner(); };
  $("#btnClearAll").onclick = ()=>{ clearAll(); renderPlanner(); };

  $("#btnSaveCustom").onclick = ()=>{ saveState(); alert("Saved."); };
  $("#btnResetCustom").onclick = ()=>{
    if (!confirm("Reset custom exercises for this template?")) return;
    const tpl=TEMPLATES[state.template];
    if (tpl.type==="BTS"){
      state.btsStacks = buildDefaultStacksBTS(state.template);
    } else {
      state.psStacks = buildDefaultStacksPS();
    }
    saveState();
    renderCustom();
    renderPlanner();
  };

  // ===== init =====
  setRulesText();
  renderCustom();
  renderPlanner();
})();
</script>
</body>
</html>
